// Force Gradle to use the correct user home directory
// Version: 3.1 - Ultra-robust with comprehensive error handling and code optimization
// This script prevents Gradle from using /Volumes/T7/gradle

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

/**
 * Comprehensive function to get user home - handles all edge cases
 * Priority order: HOME env -> USER_HOME env -> user.home property -> /Users/USER -> /Users/athalia
 */
def getUserHome() {
    def home = null
    
    // Priority 1: Environment variable HOME (most reliable)
    home = System.getenv("HOME")
    if (home != null && !home.isEmpty() && !home.startsWith("/Volumes/") && new File(home).exists()) {
        return home
    }
    
    // Priority 2: Environment variable USER_HOME
    home = System.getenv("USER_HOME")
    if (home != null && !home.isEmpty() && !home.startsWith("/Volumes/") && new File(home).exists()) {
        return home
    }
    
    // Priority 3: System property user.home
    home = System.getProperty("user.home")
    if (home != null && !home.isEmpty() && !home.startsWith("/Volumes/") && new File(home).exists()) {
        return home
    }
    
    // Priority 4: Construct from USER environment variable
    def user = System.getenv("USER")
    if (user != null && !user.isEmpty()) {
        home = "/Users/${user}"
        if (new File(home).exists()) {
            return home
        }
    }
    
    // Priority 5: Fallback to explicit username
    home = "/Users/athalia"
    if (new File(home).exists()) {
        return home
    }
    
    // Last resort: Use system property even if on volume (better than nothing)
    return System.getProperty("user.home") ?: System.getenv("HOME") ?: "/Users/athalia"
}

/**
 * Get fallback home directory based on USER environment variable
 */
def getFallbackHome() {
    def user = System.getenv("USER")
    return "/Users/${user ?: "athalia"}"
}

/**
 * Ensure .gradle directory exists and is writable
 */
def ensureGradleHome(gradleHome) {
    if (gradleHome == null) {
        return false
    }
    
    if (!gradleHome.exists()) {
        try {
            gradleHome.mkdirs()
            println "‚úÖ Init.gradle: Created directory: ${gradleHome.absolutePath}"
        } catch (Exception e) {
            println "‚ö†Ô∏è  Init.gradle: Could not create ${gradleHome.absolutePath}: ${e.message}"
            return false
        }
    }
    
    // Verify it's writable
    if (!gradleHome.canWrite()) {
        println "‚ö†Ô∏è  Init.gradle: Warning - ${gradleHome.absolutePath} is not writable"
        return false
    }
    
    return true
}

/**
 * Set Gradle user home properties and ensure directory exists
 */
def setGradleUserHome(gradleHome) {
    if (gradleHome == null) {
        return false
    }
    
    try {
        System.setProperty("org.gradle.user.home", gradleHome.absolutePath)
        System.setProperty("gradle.user.home", gradleHome.absolutePath)
        ensureGradleHome(gradleHome)
        return true
    } catch (Exception e) {
        println "‚ö†Ô∏è  Init.gradle: Error setting gradle home: ${e.message}"
        return false
    }
}

/**
 * Validate that a path is safe (not on volume, parent exists)
 */
def isPathSafe(file) {
    if (file == null) {
        return false
    }
    def parent = file.parentFile
    return parent != null && parent.exists() && !parent.absolutePath.startsWith("/Volumes/")
}

/**
 * Force Gradle user home with fallback mechanism
 */
def forceGradleUserHome(settings, gradleHome, context) {
    if (isPathSafe(gradleHome)) {
        try {
            if (settings != null) {
                settings.gradle.gradleUserHomeDir = gradleHome
            }
            setGradleUserHome(gradleHome)
            println "‚úÖ Init.gradle (${context}): Gradle user home forced to: ${gradleHome.absolutePath}"
            return true
        } catch (Exception e) {
            println "‚ö†Ô∏è  Init.gradle (${context}): Error setting gradle home: ${e.message}"
        }
    }
    
    // Use fallback
    def fallback = new File(getFallbackHome(), ".gradle")
    try {
        if (settings != null) {
            settings.gradle.gradleUserHomeDir = fallback
        }
        setGradleUserHome(fallback)
        println "‚úÖ Init.gradle (${context}): Using fallback: ${fallback.absolutePath}"
        return true
    } catch (Exception e) {
        println "‚ö†Ô∏è  Init.gradle (${context}): Fallback failed: ${e.message}"
        return false
    }
}

// ============================================================================
// INITIALIZATION
// ============================================================================

// Get and validate user home
def userHome = getUserHome()
def gradleUserHome = new File(userHome, ".gradle")

// Force system properties BEFORE anything else (critical for early initialization)
if (userHome != null && !userHome.isEmpty() && !userHome.startsWith("/Volumes/")) {
    System.setProperty("user.home", userHome)
    setGradleUserHome(gradleUserHome)
    println "‚úÖ Init.gradle: System properties set - user.home=${userHome}, gradle.user.home=${gradleUserHome.absolutePath}"
} else {
    // Even if on volume, try to set a fallback
    def fallbackHome = getFallbackHome()
    def fallbackGradleHome = new File(fallbackHome, ".gradle")
    System.setProperty("user.home", fallbackHome)
    setGradleUserHome(fallbackGradleHome)
    println "‚ö†Ô∏è  Init.gradle: Using fallback - user.home=${fallbackHome}, gradle.user.home=${fallbackGradleHome.absolutePath}"
}

// ============================================================================
// GRADLE HOOKS - Multiple levels of protection
// ============================================================================

// Force at settings level (runs first - most critical)
beforeSettings { settings ->
    def gh = new File(getUserHome(), ".gradle")
    forceGradleUserHome(settings, gh, "beforeSettings")
}

// Force at settings evaluated (runs after settings are loaded - double check)
settingsEvaluated { settings ->
    def gh = new File(getUserHome(), ".gradle")
    forceGradleUserHome(settings, gh, "settingsEvaluated")
}

// Force at project level (final check)
projectsLoaded {
    def gh = new File(getUserHome(), ".gradle")
    if (isPathSafe(gh)) {
        try {
            rootProject.ext.gradleUserHome = gh
            setGradleUserHome(gh)
            println "‚úÖ Init.gradle (projectsLoaded): Project-level Gradle user home set to: ${gh.absolutePath}"
        } catch (Exception e) {
            println "‚ö†Ô∏è  Init.gradle (projectsLoaded): Error: ${e.message}"
        }
    } else {
        def fallback = new File(getFallbackHome(), ".gradle")
        try {
            rootProject.ext.gradleUserHome = fallback
            setGradleUserHome(fallback)
            println "‚úÖ Init.gradle (projectsLoaded): Using fallback: ${fallback.absolutePath}"
        } catch (Exception e) {
            println "‚ö†Ô∏è  Init.gradle (projectsLoaded): Fallback failed: ${e.message}"
        }
    }
}

// ============================================================================
// PREVENTION ULTIME : Ignorer les fichiers macOS au niveau init.gradle
// ============================================================================

// Fonction ULTRA-AGGRESSIVE pour nettoyer TOUS les fichiers macOS
// Nettoie dans TOUS les r√©pertoires possibles, y compris les r√©pertoires interm√©diaires
def cleanMacOSFiles(dir) {
    if (dir == null || !dir.exists()) {
        return 0
    }
    
    int count = 0
    try {
        dir.eachFileRecurse { file ->
            if (file.isFile() && (file.name.startsWith("._") || file.name == ".DS_Store")) {
                try {
                    file.delete()
                    count++
                } catch (Exception e) {
                    // Ignorer les erreurs de suppression
                }
            }
        }
    } catch (Exception e) {
        // Ignorer les erreurs de parcours
    }
    return count
}

// Fonction pour nettoyer TOUS les fichiers macOS dans TOUT le projet
def cleanAllMacOSFiles(project) {
    int totalCleaned = 0
    
    // Liste de TOUS les r√©pertoires √† nettoyer
    def dirsToClean = []
    
    // R√©pertoires de build
    if (project.buildDir != null) {
        dirsToClean.add(project.buildDir)
    }
    if (project.rootProject.buildDir != null) {
        dirsToClean.add(project.rootProject.buildDir)
    }
    
    // R√©pertoires sources
    dirsToClean.add(project.file("src"))
    dirsToClean.add(project.file("lib"))
    dirsToClean.add(project.file("assets"))
    dirsToClean.add(project.file("res"))
    
    // R√©pertoires Gradle et Flutter (plus agressif)
    dirsToClean.add(project.file(".gradle"))
    dirsToClean.add(project.file("../.dart_tool"))
    dirsToClean.add(project.file("../.flutter-plugins"))
    
    // Nettoyer aussi dans le r√©pertoire android/.gradle
    def androidGradleDir = project.file(".gradle")
    if (androidGradleDir != null && androidGradleDir.exists()) {
        dirsToClean.add(androidGradleDir)
    }
    
    // Nettoyer dans le r√©pertoire parent (arkalia_cia)
    def parentDir = project.file("..")
    if (parentDir != null && parentDir.exists()) {
        // Nettoyer dans .dart_tool du projet Flutter
        def dartToolDir = new File(parentDir, ".dart_tool")
        if (dartToolDir.exists()) {
            dirsToClean.add(dartToolDir)
        }
        // Nettoyer dans build du projet Flutter
        def flutterBuildDir = new File(parentDir, "build")
        if (flutterBuildDir.exists()) {
            dirsToClean.add(flutterBuildDir)
        }
    }
    
    // R√©pertoire racine du projet Flutter
    def flutterRoot = project.file("../..")
    if (flutterRoot != null && flutterRoot.exists()) {
        dirsToClean.add(flutterRoot)
    }
    
    // R√©pertoires interm√©diaires Android
    def buildDir = project.buildDir
    if (buildDir != null && buildDir.exists()) {
        // Nettoyer dans tous les sous-r√©pertoires de build (r√©cursif)
        buildDir.eachDirRecurse { subDir ->
            dirsToClean.add(subDir)
        }
        // Nettoyer aussi les fichiers directement dans buildDir
        dirsToClean.add(buildDir)
    }
    
    // Nettoyer aussi dans le r√©pertoire build global
    def rootBuildDir = project.rootProject.buildDir
    if (rootBuildDir != null && rootBuildDir.exists()) {
        rootBuildDir.eachDirRecurse { subDir ->
            dirsToClean.add(subDir)
        }
        dirsToClean.add(rootBuildDir)
    }
    
    // Nettoyer dans les r√©pertoires interm√©diaires sp√©cifiques des plugins
    def intermediatesDir = project.file("${project.buildDir}/intermediates")
    if (intermediatesDir != null && intermediatesDir.exists()) {
        intermediatesDir.eachDirRecurse { subDir ->
            dirsToClean.add(subDir)
        }
        dirsToClean.add(intermediatesDir)
    }
    
    // Nettoyer dans packaged_res (o√π l'erreur se produit)
    def packagedResDir = project.file("${project.buildDir}/intermediates/packaged_res")
    if (packagedResDir != null && packagedResDir.exists()) {
        packagedResDir.eachDirRecurse { subDir ->
            dirsToClean.add(subDir)
        }
        dirsToClean.add(packagedResDir)
    }
    
    // Nettoyer tous les r√©pertoires
    dirsToClean.each { dir ->
        if (dir != null && dir.exists()) {
            totalCleaned += cleanMacOSFiles(dir)
        }
    }
    
    return totalCleaned
}

// ============================================================================
// CLASSE HELPER : AndroidExtension pour cr√©er une extension android factice
// ============================================================================
// Cette classe doit √™tre d√©finie au niveau racine pour √™tre accessible
// dans tous les blocs du script
class AndroidExtension {
    def flutter
    
    AndroidExtension(def flutterConfig) {
        this.flutter = flutterConfig
    }
}

// ========================================================================
// CONFIGURATION FLUTTER.SOURCE - TR√àS T√îT AVANT TOUT
// ========================================================================
// Le plugin Flutter Gradle lit flutter.source au moment o√π il est charg√©
// via includeBuild dans pluginManagement. On doit le configurer AVANT.
// init.gradle s'ex√©cute AVANT settings.gradle.kts, donc c'est le bon endroit.

// Lire depuis -P (priorit√© maximale)
def flutterSourceFromSystem = gradle.startParameter.projectProperties["flutter.source"]

// Si pas dans -P, lire depuis gradle.properties
if (flutterSourceFromSystem == null) {
    def gradlePropsFile = new File(settingsDir, "gradle.properties")
    if (gradlePropsFile.exists()) {
        def gradleProps = new Properties()
        gradlePropsFile.withInputStream { gradleProps.load(it) }
        def flutterSourceFromProps = gradleProps.getProperty("flutter.source")
        
        if (flutterSourceFromProps != null) {
            def sourceFile = new File(flutterSourceFromProps)
            // Toujours convertir en absolu
            flutterSourceFromSystem = sourceFile.isAbsolute() ? 
                sourceFile.absolutePath : 
                sourceFile.absoluteFile.absolutePath
            
            // Mettre √† jour gradle.properties avec le chemin absolu
            gradleProps.setProperty("flutter.source", flutterSourceFromSystem)
            gradlePropsFile.withOutputStream { gradleProps.store(it, null) }
        }
    }
}

// Si toujours pas d√©fini, utiliser le fallback
if (flutterSourceFromSystem == null) {
    // settingsDir = android/, donc parent = arkalia_cia/
    def fallbackFile = new File(settingsDir, "..")
    flutterSourceFromSystem = fallbackFile.absolutePath
    
    // Ajouter √† gradle.properties
    def gradlePropsFile = new File(settingsDir, "gradle.properties")
    if (gradlePropsFile.exists()) {
        def gradleProps = new Properties()
        gradlePropsFile.withInputStream { gradleProps.load(it) }
        gradleProps.setProperty("flutter.source", flutterSourceFromSystem)
        gradlePropsFile.withOutputStream { gradleProps.store(it, null) }
    }
}

// Configurer dans les propri√©t√©s syst√®me Gradle AVANT que le plugin ne soit charg√©
if (flutterSourceFromSystem != null) {
    if (!gradle.startParameter.projectProperties.containsKey("flutter.source")) {
        gradle.startParameter.projectProperties["flutter.source"] = flutterSourceFromSystem
    }
    
    // Aussi dans local.properties qui est lu tr√®s t√¥t
    def localPropsFile = new File(settingsDir, "local.properties")
    if (localPropsFile.exists()) {
        def localProps = new Properties()
        localPropsFile.withInputStream { localProps.load(it) }
        localProps.setProperty("flutter.source", flutterSourceFromSystem)
        localPropsFile.withOutputStream { localProps.store(it, null) }
    }
    
    println "‚úÖ Init.gradle: Flutter source directory configur√©: $flutterSourceFromSystem"
}

// Prevent any volume-based cache creation (proactive prevention)
gradle.beforeProject { project ->
    def currentUserHome = System.getProperty("org.gradle.user.home")
    if (currentUserHome != null && currentUserHome.startsWith("/Volumes/")) {
        def correctHome = new File(getFallbackHome(), ".gradle")
        setGradleUserHome(correctHome)
        println "‚úÖ Init.gradle (beforeProject): Corrected volume-based path to: ${correctHome.absolutePath}"
    }
    
    // ========================================================================
    // CONFIGURATION FLUTTER EXTENSION - TR√àS T√îT pour file_picker
    // ========================================================================
    // Cette configuration doit se faire AVANT m√™me que les plugins ne soient √©valu√©s
    // pour que file_picker puisse acc√©der √† android.flutter.compileSdkVersion
    // Lire le versionCode depuis pubspec.yaml au lieu d'utiliser 1
    def versionCodeFromPubspec = 1
    def versionNameFromPubspec = "1.0.0"
    try {
        def pubspecFile = new File(project.projectDir.parentFile.parentFile, "pubspec.yaml")
        if (pubspecFile.exists()) {
            def pubspecContent = pubspecFile.text
            def versionLine = pubspecContent.readLines().find { it.trim().startsWith("version:") }
            if (versionLine != null) {
                def parts = versionLine.split("\\+")
                if (parts.size() > 1) {
                    def codeStr = parts[1].trim()
                    versionCodeFromPubspec = codeStr.toInteger()
                    versionNameFromPubspec = parts[0].replace("version:", "").trim()
                    println("‚úÖ [init.gradle] Version lue depuis pubspec.yaml: $versionNameFromPubspec+$versionCodeFromPubspec")
                }
            }
        }
    } catch (Exception e) {
        println("‚ö†Ô∏è [init.gradle] Erreur lecture pubspec.yaml: ${e.message}, utilisation valeurs par d√©faut")
    }
    
    def flutterConfig = [
        minSdkVersion: 21,
        targetSdkVersion: 36,
        compileSdkVersion: 36,
        versionCode: versionCodeFromPubspec,
        versionName: versionNameFromPubspec
    ]
    
    // Stocker dans project.ext pour qu'il soit accessible partout
    if (!project.ext.has("flutter")) {
        project.ext.flutter = flutterConfig
    }
    
    // Cr√©er l'extension android avec flutter AVANT que le plugin Android ne soit appliqu√©
    // On utilise beforeEvaluate pour s'ex√©cuter AVANT l'√©valuation du build.gradle
    // IMPORTANT: Cette configuration doit se faire AVANT que les plugins ne soient appliqu√©s
    project.beforeEvaluate {
        try {
            // Si android n'existe pas encore, cr√©er une extension factice
            if (!project.hasProperty("android")) {
                // Cr√©er une extension android factice avec la propri√©t√© flutter
                project.extensions.create("android", AndroidExtension, flutterConfig)
                println "‚úÖ Init.gradle (beforeProject): Cr√©√© extension android factice pour ${project.name}"
            }
        } catch (Exception e) {
            // Ignorer si la configuration √©choue
            println "‚ö†Ô∏è  Init.gradle (beforeProject): Erreur cr√©ation android factice pour ${project.name}: ${e.message}"
        }
    }
    
    // Configuration APR√àS que le plugin Android soit appliqu√© pour ajouter flutter
    project.afterEvaluate {
        try {
            if (project.hasProperty("android")) {
                def android = project.extensions.findByName("android")
                if (android != null) {
                    // Utiliser metaClass pour ajouter la propri√©t√© flutter
                    android.metaClass.flutter = flutterConfig
                    if (!android.hasProperty("flutter")) {
                        android.ext.flutter = flutterConfig
                    }
                    println "‚úÖ Init.gradle (beforeProject): Ajout√© flutter √† android pour ${project.name}"
                }
            }
        } catch (Exception e) {
            // Ignorer si la configuration √©choue
            println "‚ö†Ô∏è  Init.gradle (beforeProject): Erreur ajout flutter √† android pour ${project.name}: ${e.message}"
        }
    }
    
    // ========================================================================
    // NETTOYAGE ULTRA-AGGRESSIF AVANT ET APR√àS CHAQUE T√ÇCHE
    // ========================================================================
    project.tasks.configureEach { task ->
        // Nettoyer AVANT l'ex√©cution de la t√¢che (nettoyage complet)
        task.doFirst {
            int totalCleaned = cleanAllMacOSFiles(project)
            if (totalCleaned > 0) {
                println "üßπ Init.gradle: Nettoy√© $totalCleaned fichiers macOS avant ${task.name}"
            }
        }
        
        // Nettoyer APR√àS l'ex√©cution de la t√¢che (pour les fichiers recr√©√©s)
        task.doLast {
            int cleaned = cleanAllMacOSFiles(project)
            if (cleaned > 0) {
                println "üßπ Init.gradle: Nettoy√© $cleaned fichiers macOS apr√®s ${task.name}"
            }
        }
    }
    
    // ========================================================================
    // NETTOYAGE SP√âCIAL POUR LES T√ÇCHES ANDROID CRITIQUES
    // ========================================================================
    // Nettoyer AVANT les t√¢ches qui traitent les ressources (o√π les fichiers sont cr√©√©s)
    project.tasks.matching { 
        it.name.contains("process") || 
        it.name.contains("merge") || 
        it.name.contains("link") ||
        it.name.contains("compile") ||
        it.name.contains("assemble") ||
        it.name.contains("parse") ||
        it.name.contains("package") ||
        it.name.contains("resource")
    }.configureEach { task ->
        task.doFirst {
            // Nettoyage ultra-agressif juste avant ces t√¢ches critiques
            // Nettoyer aussi dans les r√©pertoires interm√©diaires sp√©cifiques
            def buildDir = project.buildDir
            if (buildDir != null && buildDir.exists()) {
                // Nettoyer dans tous les r√©pertoires interm√©diaires (r√©cursif)
                try {
                    buildDir.eachFileRecurse { file ->
                        if (file.isFile() && (file.name.startsWith("._") || file.name == ".DS_Store")) {
                            try {
                                file.delete()
                            } catch (Exception e) {
                                // Ignorer les erreurs
                            }
                        }
                    }
                } catch (Exception e) {
                    // Ignorer les erreurs de parcours
                }
            }
            
            // Nettoyer sp√©cifiquement dans packaged_res (o√π l'erreur se produit)
            def packagedResDir = project.file("${project.buildDir}/intermediates/packaged_res")
            if (packagedResDir != null && packagedResDir.exists()) {
                try {
                    packagedResDir.eachFileRecurse { file ->
                        if (file.isFile() && (file.name.startsWith("._") || file.name == ".DS_Store")) {
                            try {
                                file.delete()
                            } catch (Exception e) {
                                // Ignorer les erreurs
                            }
                        }
                    }
                } catch (Exception e) {
                    // Ignorer les erreurs de parcours
                }
            }
            
            int cleaned = cleanAllMacOSFiles(project)
            if (cleaned > 0) {
                println "üßπ Init.gradle: Nettoyage critique - $cleaned fichiers macOS supprim√©s avant ${task.name}"
            }
        }
    }
    
    // ========================================================================
    // CONFIGURATION GLOBALE : Exclure les fichiers macOS de TOUS les FileTree
    // ========================================================================
    // Cette configuration s'applique √† tous les FileTree cr√©√©s dans le projet
    project.extensions.extraProperties.set("macosExcludePatterns", [
        "**/._*",
        "**/._*/**",
        "**/.DS_Store",
        "**/.DS_Store?",
        "**/.AppleDouble",
        "**/.AppleDouble/**"
    ])
    
    // ========================================================================
    // CONFIGURATION POUR PLUGINS FLUTTER : Forcer compileSdkVersion
    // ========================================================================
    // Corrige le probl√®me avec file_picker et autres plugins qui essaient
    // d'acc√©der √† android.flutter avant que le plugin Flutter ne soit appliqu√©
    
    // Configuration AVANT l'√©valuation pour intercepter les acc√®s √† android.flutter
    // IMPORTANT: Cette configuration doit se faire TR√àS T√îT, avant m√™me que les plugins
    // ne soient √©valu√©s, pour que file_picker puisse acc√©der √† android.flutter
    // On utilise project.beforeEvaluate pour s'ex√©cuter AVANT l'√©valuation du build.gradle du plugin
    // Note: flutterConfig est d√©j√† d√©fini dans le scope parent (gradle.beforeProject)
    project.beforeEvaluate {
        // Cr√©er une extension flutter factice si elle n'existe pas
        // Cela permet aux plugins Groovy d'acc√©der √† android.flutter sans erreur
        try {
            // Stocker dans project.ext pour qu'il soit accessible partout
            if (!project.ext.has("flutter")) {
                project.ext.flutter = flutterConfig
            }
            
            // Cr√©er une extension android factice si elle n'existe pas encore
            // Cela permet √† file_picker d'acc√©der √† android.flutter m√™me si android n'est pas encore cr√©√©
            if (!project.hasProperty("android")) {
                // Cr√©er une extension android factice avec la propri√©t√© flutter
                project.extensions.create("android", AndroidExtension, flutterConfig)
            } else {
                // Si android existe d√©j√†, ajouter la propri√©t√© flutter via metaClass
                try {
                    def android = project.extensions.findByName("android")
                    if (android != null) {
                        // Utiliser metaClass pour ajouter la propri√©t√© flutter
                        android.metaClass.flutter = flutterConfig
                        // Aussi d√©finir via ext pour compatibilit√©
                        if (!android.hasProperty("flutter")) {
                            android.ext.flutter = flutterConfig
                        }
                    }
                } catch (Exception e) {
                    // Ignorer si android n'est pas encore disponible
                }
            }
            
            println "‚úÖ Init.gradle: Cr√©√© extension flutter factice pour ${project.name}"
        } catch (Exception e) {
            // Ignorer si la configuration √©choue
            println "‚ö†Ô∏è  Init.gradle: Erreur cr√©ation extension flutter pour ${project.name}: ${e.message}"
        }
    }
    
    // Configuration APR√àS l'√©valuation pour forcer compileSdkVersion
    project.afterEvaluate {
        if (project.hasProperty("android")) {
            try {
                def android = project.android
                if (android != null) {
                    // Forcer compileSdkVersion pour les plugins Flutter (compatible Groovy)
                    try {
                        // Essayer d'acc√©der √† compileSdkVersion (Groovy)
                        if (android.metaClass.hasProperty(android, 'compileSdkVersion')) {
                            def currentSdk = android.compileSdkVersion
                            if (currentSdk == null) {
                                android.compileSdkVersion = 36
                                println "‚úÖ Init.gradle: Forc√© compileSdkVersion=36 pour ${project.name}"
                            }
                        }
                    } catch (Exception e) {
                        // Si compileSdkVersion n'existe pas, essayer compileSdk (Kotlin DSL)
                        try {
                            if (android.metaClass.hasProperty(android, 'compileSdk')) {
                                def currentSdk = android.compileSdk
                                if (currentSdk == null) {
                                    android.compileSdk = 36
                                    println "‚úÖ Init.gradle: Forc√© compileSdk=36 pour ${project.name}"
                                }
                            }
                        } catch (Exception e2) {
                            // Derni√®re tentative : utiliser setCompileSdkVersion si disponible
                            try {
                                android.setCompileSdkVersion(36)
                                println "‚úÖ Init.gradle: Forc√© compileSdkVersion=36 via setter pour ${project.name}"
                            } catch (Exception e3) {
                                // Ignorer si aucune m√©thode ne fonctionne
                                println "‚ö†Ô∏è  Init.gradle: Impossible de forcer compileSdk pour ${project.name}"
                            }
                        }
                    }
                }
            } catch (Exception e) {
                println "‚ö†Ô∏è  Init.gradle: Erreur configuration compileSdk pour ${project.name}: ${e.message}"
            }
        }
    }
}
