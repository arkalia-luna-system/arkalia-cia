// Force Gradle to use the correct user home directory
// Version: 3.1 - Ultra-robust with comprehensive error handling and code optimization
// This script prevents Gradle from using /Volumes/T7/gradle

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

/**
 * Comprehensive function to get user home - handles all edge cases
 * Priority order: HOME env -> USER_HOME env -> user.home property -> /Users/USER -> /Users/athalia
 */
def getUserHome() {
    def home = null
    
    // Priority 1: Environment variable HOME (most reliable)
    home = System.getenv("HOME")
    if (home != null && !home.isEmpty() && !home.startsWith("/Volumes/") && new File(home).exists()) {
        return home
    }
    
    // Priority 2: Environment variable USER_HOME
    home = System.getenv("USER_HOME")
    if (home != null && !home.isEmpty() && !home.startsWith("/Volumes/") && new File(home).exists()) {
        return home
    }
    
    // Priority 3: System property user.home
    home = System.getProperty("user.home")
    if (home != null && !home.isEmpty() && !home.startsWith("/Volumes/") && new File(home).exists()) {
        return home
    }
    
    // Priority 4: Construct from USER environment variable
    def user = System.getenv("USER")
    if (user != null && !user.isEmpty()) {
        home = "/Users/${user}"
        if (new File(home).exists()) {
            return home
        }
    }
    
    // Priority 5: Fallback to explicit username
    home = "/Users/athalia"
    if (new File(home).exists()) {
        return home
    }
    
    // Last resort: Use system property even if on volume (better than nothing)
    return System.getProperty("user.home") ?: System.getenv("HOME") ?: "/Users/athalia"
}

/**
 * Get fallback home directory based on USER environment variable
 */
def getFallbackHome() {
    def user = System.getenv("USER")
    return "/Users/${user ?: "athalia"}"
}

/**
 * Ensure .gradle directory exists and is writable
 */
def ensureGradleHome(gradleHome) {
    if (gradleHome == null) {
        return false
    }
    
    if (!gradleHome.exists()) {
        try {
            gradleHome.mkdirs()
            println "‚úÖ Init.gradle: Created directory: ${gradleHome.absolutePath}"
        } catch (Exception e) {
            println "‚ö†Ô∏è  Init.gradle: Could not create ${gradleHome.absolutePath}: ${e.message}"
            return false
        }
    }
    
    // Verify it's writable
    if (!gradleHome.canWrite()) {
        println "‚ö†Ô∏è  Init.gradle: Warning - ${gradleHome.absolutePath} is not writable"
        return false
    }
    
    return true
}

/**
 * Set Gradle user home properties and ensure directory exists
 */
def setGradleUserHome(gradleHome) {
    if (gradleHome == null) {
        return false
    }
    
    try {
        System.setProperty("org.gradle.user.home", gradleHome.absolutePath)
        System.setProperty("gradle.user.home", gradleHome.absolutePath)
        ensureGradleHome(gradleHome)
        return true
    } catch (Exception e) {
        println "‚ö†Ô∏è  Init.gradle: Error setting gradle home: ${e.message}"
        return false
    }
}

/**
 * Validate that a path is safe (not on volume, parent exists)
 */
def isPathSafe(file) {
    if (file == null) {
        return false
    }
    def parent = file.parentFile
    return parent != null && parent.exists() && !parent.absolutePath.startsWith("/Volumes/")
}

/**
 * Force Gradle user home with fallback mechanism
 */
def forceGradleUserHome(settings, gradleHome, context) {
    if (isPathSafe(gradleHome)) {
        try {
            if (settings != null) {
                settings.gradle.gradleUserHomeDir = gradleHome
            }
            setGradleUserHome(gradleHome)
            println "‚úÖ Init.gradle (${context}): Gradle user home forced to: ${gradleHome.absolutePath}"
            return true
        } catch (Exception e) {
            println "‚ö†Ô∏è  Init.gradle (${context}): Error setting gradle home: ${e.message}"
        }
    }
    
    // Use fallback
    def fallback = new File(getFallbackHome(), ".gradle")
    try {
        if (settings != null) {
            settings.gradle.gradleUserHomeDir = fallback
        }
        setGradleUserHome(fallback)
        println "‚úÖ Init.gradle (${context}): Using fallback: ${fallback.absolutePath}"
        return true
    } catch (Exception e) {
        println "‚ö†Ô∏è  Init.gradle (${context}): Fallback failed: ${e.message}"
        return false
    }
}

// ============================================================================
// INITIALIZATION
// ============================================================================

// Get and validate user home
def userHome = getUserHome()
def gradleUserHome = new File(userHome, ".gradle")

// Force system properties BEFORE anything else (critical for early initialization)
if (userHome != null && !userHome.isEmpty() && !userHome.startsWith("/Volumes/")) {
    System.setProperty("user.home", userHome)
    setGradleUserHome(gradleUserHome)
    println "‚úÖ Init.gradle: System properties set - user.home=${userHome}, gradle.user.home=${gradleUserHome.absolutePath}"
} else {
    // Even if on volume, try to set a fallback
    def fallbackHome = getFallbackHome()
    def fallbackGradleHome = new File(fallbackHome, ".gradle")
    System.setProperty("user.home", fallbackHome)
    setGradleUserHome(fallbackGradleHome)
    println "‚ö†Ô∏è  Init.gradle: Using fallback - user.home=${fallbackHome}, gradle.user.home=${fallbackGradleHome.absolutePath}"
}

// ============================================================================
// GRADLE HOOKS - Multiple levels of protection
// ============================================================================

// Force at settings level (runs first - most critical)
beforeSettings { settings ->
    def gh = new File(getUserHome(), ".gradle")
    forceGradleUserHome(settings, gh, "beforeSettings")
}

// Force at settings evaluated (runs after settings are loaded - double check)
settingsEvaluated { settings ->
    def gh = new File(getUserHome(), ".gradle")
    forceGradleUserHome(settings, gh, "settingsEvaluated")
}

// Force at project level (final check)
projectsLoaded {
    def gh = new File(getUserHome(), ".gradle")
    if (isPathSafe(gh)) {
        try {
            rootProject.ext.gradleUserHome = gh
            setGradleUserHome(gh)
            println "‚úÖ Init.gradle (projectsLoaded): Project-level Gradle user home set to: ${gh.absolutePath}"
        } catch (Exception e) {
            println "‚ö†Ô∏è  Init.gradle (projectsLoaded): Error: ${e.message}"
        }
    } else {
        def fallback = new File(getFallbackHome(), ".gradle")
        try {
            rootProject.ext.gradleUserHome = fallback
            setGradleUserHome(fallback)
            println "‚úÖ Init.gradle (projectsLoaded): Using fallback: ${fallback.absolutePath}"
        } catch (Exception e) {
            println "‚ö†Ô∏è  Init.gradle (projectsLoaded): Fallback failed: ${e.message}"
        }
    }
}

// ============================================================================
// PREVENTION ULTIME : Ignorer les fichiers macOS au niveau init.gradle
// ============================================================================

// Fonction ULTRA-AGGRESSIVE pour nettoyer TOUS les fichiers macOS
// Nettoie dans TOUS les r√©pertoires possibles, y compris les r√©pertoires interm√©diaires
def cleanMacOSFiles(dir) {
    if (dir == null || !dir.exists()) {
        return 0
    }
    
    int count = 0
    try {
        dir.eachFileRecurse { file ->
            if (file.isFile() && (file.name.startsWith("._") || file.name == ".DS_Store")) {
                try {
                    file.delete()
                    count++
                } catch (Exception e) {
                    // Ignorer les erreurs de suppression
                }
            }
        }
    } catch (Exception e) {
        // Ignorer les erreurs de parcours
    }
    return count
}

// Fonction pour nettoyer TOUS les fichiers macOS dans TOUT le projet
def cleanAllMacOSFiles(project) {
    int totalCleaned = 0
    
    // Liste de TOUS les r√©pertoires √† nettoyer
    def dirsToClean = []
    
    // R√©pertoires de build
    if (project.buildDir != null) {
        dirsToClean.add(project.buildDir)
    }
    if (project.rootProject.buildDir != null) {
        dirsToClean.add(project.rootProject.buildDir)
    }
    
    // R√©pertoires sources
    dirsToClean.add(project.file("src"))
    dirsToClean.add(project.file("lib"))
    dirsToClean.add(project.file("assets"))
    dirsToClean.add(project.file("res"))
    
    // R√©pertoires Gradle et Flutter (plus agressif)
    dirsToClean.add(project.file(".gradle"))
    dirsToClean.add(project.file("../.dart_tool"))
    dirsToClean.add(project.file("../.flutter-plugins"))
    
    // Nettoyer aussi dans le r√©pertoire android/.gradle
    def androidGradleDir = project.file(".gradle")
    if (androidGradleDir != null && androidGradleDir.exists()) {
        dirsToClean.add(androidGradleDir)
    }
    
    // Nettoyer dans le r√©pertoire parent (arkalia_cia)
    def parentDir = project.file("..")
    if (parentDir != null && parentDir.exists()) {
        // Nettoyer dans .dart_tool du projet Flutter
        def dartToolDir = new File(parentDir, ".dart_tool")
        if (dartToolDir.exists()) {
            dirsToClean.add(dartToolDir)
        }
        // Nettoyer dans build du projet Flutter
        def flutterBuildDir = new File(parentDir, "build")
        if (flutterBuildDir.exists()) {
            dirsToClean.add(flutterBuildDir)
        }
    }
    
    // R√©pertoire racine du projet Flutter
    def flutterRoot = project.file("../..")
    if (flutterRoot != null && flutterRoot.exists()) {
        dirsToClean.add(flutterRoot)
    }
    
    // R√©pertoires interm√©diaires Android
    def buildDir = project.buildDir
    if (buildDir != null && buildDir.exists()) {
        // Nettoyer dans tous les sous-r√©pertoires de build (r√©cursif)
        buildDir.eachDirRecurse { subDir ->
            dirsToClean.add(subDir)
        }
        // Nettoyer aussi les fichiers directement dans buildDir
        dirsToClean.add(buildDir)
    }
    
    // Nettoyer aussi dans le r√©pertoire build global
    def rootBuildDir = project.rootProject.buildDir
    if (rootBuildDir != null && rootBuildDir.exists()) {
        rootBuildDir.eachDirRecurse { subDir ->
            dirsToClean.add(subDir)
        }
        dirsToClean.add(rootBuildDir)
    }
    
    // Nettoyer dans les r√©pertoires interm√©diaires sp√©cifiques des plugins
    def intermediatesDir = project.file("${project.buildDir}/intermediates")
    if (intermediatesDir != null && intermediatesDir.exists()) {
        intermediatesDir.eachDirRecurse { subDir ->
            dirsToClean.add(subDir)
        }
        dirsToClean.add(intermediatesDir)
    }
    
    // Nettoyer dans packaged_res (o√π l'erreur se produit)
    def packagedResDir = project.file("${project.buildDir}/intermediates/packaged_res")
    if (packagedResDir != null && packagedResDir.exists()) {
        packagedResDir.eachDirRecurse { subDir ->
            dirsToClean.add(subDir)
        }
        dirsToClean.add(packagedResDir)
    }
    
    // Nettoyer tous les r√©pertoires
    dirsToClean.each { dir ->
        if (dir != null && dir.exists()) {
            totalCleaned += cleanMacOSFiles(dir)
        }
    }
    
    return totalCleaned
}

// Prevent any volume-based cache creation (proactive prevention)
gradle.beforeProject { project ->
    def currentUserHome = System.getProperty("org.gradle.user.home")
    if (currentUserHome != null && currentUserHome.startsWith("/Volumes/")) {
        def correctHome = new File(getFallbackHome(), ".gradle")
        setGradleUserHome(correctHome)
        println "‚úÖ Init.gradle (beforeProject): Corrected volume-based path to: ${correctHome.absolutePath}"
    }
    
    // ========================================================================
    // NETTOYAGE ULTRA-AGGRESSIF AVANT ET APR√àS CHAQUE T√ÇCHE
    // ========================================================================
    project.tasks.configureEach { task ->
        // Nettoyer AVANT l'ex√©cution de la t√¢che (nettoyage complet)
        task.doFirst {
            int totalCleaned = cleanAllMacOSFiles(project)
            if (totalCleaned > 0) {
                println "üßπ Init.gradle: Nettoy√© $totalCleaned fichiers macOS avant ${task.name}"
            }
        }
        
        // Nettoyer APR√àS l'ex√©cution de la t√¢che (pour les fichiers recr√©√©s)
        task.doLast {
            int cleaned = cleanAllMacOSFiles(project)
            if (cleaned > 0) {
                println "üßπ Init.gradle: Nettoy√© $cleaned fichiers macOS apr√®s ${task.name}"
            }
        }
    }
    
    // ========================================================================
    // NETTOYAGE SP√âCIAL POUR LES T√ÇCHES ANDROID CRITIQUES
    // ========================================================================
    // Nettoyer AVANT les t√¢ches qui traitent les ressources (o√π les fichiers sont cr√©√©s)
    project.tasks.matching { 
        it.name.contains("process") || 
        it.name.contains("merge") || 
        it.name.contains("link") ||
        it.name.contains("compile") ||
        it.name.contains("assemble") ||
        it.name.contains("parse") ||
        it.name.contains("package") ||
        it.name.contains("resource")
    }.configureEach { task ->
        task.doFirst {
            // Nettoyage ultra-agressif juste avant ces t√¢ches critiques
            // Nettoyer aussi dans les r√©pertoires interm√©diaires sp√©cifiques
            def buildDir = project.buildDir
            if (buildDir != null && buildDir.exists()) {
                // Nettoyer dans tous les r√©pertoires interm√©diaires (r√©cursif)
                try {
                    buildDir.eachFileRecurse { file ->
                        if (file.isFile() && (file.name.startsWith("._") || file.name == ".DS_Store")) {
                            try {
                                file.delete()
                            } catch (Exception e) {
                                // Ignorer les erreurs
                            }
                        }
                    }
                } catch (Exception e) {
                    // Ignorer les erreurs de parcours
                }
            }
            
            // Nettoyer sp√©cifiquement dans packaged_res (o√π l'erreur se produit)
            def packagedResDir = project.file("${project.buildDir}/intermediates/packaged_res")
            if (packagedResDir != null && packagedResDir.exists()) {
                try {
                    packagedResDir.eachFileRecurse { file ->
                        if (file.isFile() && (file.name.startsWith("._") || file.name == ".DS_Store")) {
                            try {
                                file.delete()
                            } catch (Exception e) {
                                // Ignorer les erreurs
                            }
                        }
                    }
                } catch (Exception e) {
                    // Ignorer les erreurs de parcours
                }
            }
            
            int cleaned = cleanAllMacOSFiles(project)
            if (cleaned > 0) {
                println "üßπ Init.gradle: Nettoyage critique - $cleaned fichiers macOS supprim√©s avant ${task.name}"
            }
        }
    }
    
    // ========================================================================
    // CONFIGURATION GLOBALE : Exclure les fichiers macOS de TOUS les FileTree
    // ========================================================================
    // Cette configuration s'applique √† tous les FileTree cr√©√©s dans le projet
    project.extensions.extraProperties.set("macosExcludePatterns", [
        "**/._*",
        "**/._*/**",
        "**/.DS_Store",
        "**/.DS_Store?",
        "**/.AppleDouble",
        "**/.AppleDouble/**"
    ])
    
    // ========================================================================
    // CONFIGURATION POUR PLUGINS FLUTTER : Forcer compileSdkVersion
    // ========================================================================
    // Corrige le probl√®me avec file_picker et autres plugins qui essaient
    // d'acc√©der √† android.flutter avant que le plugin Flutter ne soit appliqu√©
    
    // Configuration AVANT l'√©valuation pour intercepter les acc√®s √† android.flutter
    project.beforeEvaluate {
        // Cr√©er une extension flutter factice si elle n'existe pas
        // Cela permet aux plugins Groovy d'acc√©der √† android.flutter sans erreur
        if (project.hasProperty("android")) {
            try {
                def android = project.extensions.findByName("android")
                if (android != null && !android.hasProperty("flutter")) {
                    // Cr√©er une propri√©t√© flutter factice avec les valeurs par d√©faut
                    android.ext.flutter = [
                        minSdkVersion: 21,
                        targetSdkVersion: 36,
                        compileSdkVersion: 36,
                        versionCode: 1,
                        versionName: "1.0.0"
                    ]
                    println "‚úÖ Init.gradle: Cr√©√© extension flutter factice pour ${project.name}"
                }
            } catch (Exception e) {
                // Ignorer si la configuration √©choue
            }
        }
    }
    
    // Configuration APR√àS l'√©valuation pour forcer compileSdkVersion
    project.afterEvaluate {
        if (project.hasProperty("android")) {
            def android = project.android
            if (android != null) {
                // Forcer compileSdkVersion pour les plugins Flutter (compatible Groovy)
                try {
                    if (android.compileSdkVersion == null) {
                        android.compileSdkVersion = 36
                        println "‚úÖ Init.gradle: Forc√© compileSdkVersion=36 pour ${project.name}"
                    }
                } catch (Exception e) {
                    // Si compileSdkVersion n'existe pas, essayer compileSdk (Kotlin DSL)
                    try {
                        if (android.compileSdk == null) {
                            android.compileSdk = 36
                            println "‚úÖ Init.gradle: Forc√© compileSdk=36 pour ${project.name}"
                        }
                    } catch (Exception e2) {
                        // Ignorer si aucune des deux m√©thodes ne fonctionne
                    }
                }
            }
        }
    }
}
